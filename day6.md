##  解决路由缓存问题

路由只有参数变化时，会复用组件实例
相同的组件实例被复用，组件的生命周期钩子函数不会被调用

1.组件实例不复用，强制销毁重建
2.监听路由变化，变化之后执行数据更新操作

- 法一：
  - 给router-view添加key
    组件中所有请求重新发生，包括相同内容的轮播图等(粗暴，浪费)
- 法二：
  - 使用beforeRouteUpdate导航钩子函数
    可以在每次路由更新前执行，在回调中执行需要更新的数据业务逻辑即可(性能问题，精细化操作)


## 使用逻辑函数拆分业务

同一个组件中独立的业务代码通过函数做封装处理，提高代码的可维护性

1. 按照业务声明以**use**打头的逻辑函数

2.把**独立的业务逻辑**封装到各个函数内部

3.函数内部把组件中需要用到的数据或者方法**return出去**

4.在**组件中调用函数**把数据或者方法组合回来使用

## 整体认识和路由配置

二级面包屑导航
筛选条件框
商品列表(无限加载)

创建路由组件 --> 配置路由关系 --> 修改模板实现跳转
**命名导入和默认导出**


## 商品列表展示

实现基础列表渲染 --> 添加额外参数实现筛选功能 --> 无限加载功能 

实现基础列表渲染
  封装接口 --> 准备基础参数  --> 获取数据渲染列表

添加筛选参数实现筛选功能
  点击tab，切换筛选条件参数sortField，重新发送列表请求
  获取激活项数据  --> 使用新参数发送请求重新渲染列表

无线加载功能
  使用element-pius 提供的 v-infinite-scroll 指令 监听是否满足触底条件，满足加载条件时让页数参数增加一获取下一页数据，做新老数据拼接渲染

  配置v-infinite-scroll --> 页数加一获取下一页数据 --> 新老数据拼接 --> 加载完毕结束监听

## 二级分类-定制路由scrollBehavior
  在不同路由切换的时候，可以**自由滚动到页面的顶部**，而不是停留在原先的位置
  vue-route支持 scrollBehavioral 配置项，可以指定路由切换时的滚动状态